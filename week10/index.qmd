---
pagetitle: "ETC5523: Communicating with Data"
subtitle: "R Shiny — Advanced: tabsets, shared reactives, debugging, conditional UI"
author: "Michael Lydeamore"
email: "michael.lydeamore@monash.edu"
date: "Week 10"
department: "Department of Econometrics and Business Statistics"
unit-url: "cwd.numbat.space"
footer: "ETC5523 Week 10"
format: 
  revealjs:
    logo: ../images/monash-one-line-black-rgb.png
    slide-number: c
    multiplex: false
    theme: ../assets/monash.scss
    show-slide-number: all
    show-notes: true
    controls: true
    width: 1280
    height: 720
    css: [../assets/tachyons-addon.css, ../assets/custom.css]
    include-after-body: "../assets/after-body.html"
    incremental: true
execute:
  echo: true
  eval: true
---

```{r, include = FALSE}
current_file <- knitr::current_input()
basename <- gsub(".[Rq]md$", "", current_file)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.height = 4,
  fig.align = "center",
  out.width = "100%",
  fig.retina = 3,
  warning = FALSE,
  message = FALSE,
  cache = FALSE
)
```

## <br>[`r rmarkdown::metadata$pagetitle`]{.monash-blue} {#etc5523-title background-image="images/bg-01.png"}

### `r rmarkdown::metadata$subtitle`

Lecturer: *`r rmarkdown::metadata$author`*

`r rmarkdown::metadata$department`

::: tl
<br>

<ul class="fa-ul">

<li>

[<i class="fas fa-envelope"></i>]{.fa-li}`r rmarkdown::metadata$email`

</li>

<li>

[<i class="fas fa-calendar-alt"></i>]{.fa-li} `r rmarkdown::metadata$date`

</li>

<li>

[<i class="fa-solid fa-globe"></i>]{.fa-li}<a href="`r rmarkdown::metadata[["unit-url"]]`">`r rmarkdown::metadata[["unit-url"]]`</a>

</li>

</ul>

<br>
:::


## {#aim background="white"}

::: {.callout-important }

## Aim

* Tabbed layouts (tabsets) to organise views
* Shared reactive datasets / reactiveValues used across components
* More debugging techniques and diagnostics
* Auto-generated narrative text driven by reactive expressions
* Conditionally showing UI elements (show/hide based on inputs)

:::

::: fragment

::: {.callout-tip }

## Why

These patterns let you write cleaner, more efficient apps and craft persuasive narratives using the same underlying data.

:::

:::

---

```{r}
#| echo: false
#| message: false
#| warning: false
library(tidyverse)
library(tidyr)
```

## Dataset

```{r}
smartmeter <- read.csv(here::here("data", "smartmeter.csv"))

head(smartmeter)
```

## Dataset after some cleaning

```{r}
solar_data <- smartmeter |>
  pivot_longer(
    cols = starts_with("X"),
    names_to = "datetime",
    values_to = "energy_kwh"
  ) |>
  mutate(
    datetime = gsub("X(\\d{2}\\.\\d{2})\\.\\.\\.(\\d{2}\\.\\d{2})", "\\1", datetime),
    energy_kwh = as.numeric(energy_kwh),
    datetime = paste0(DATE, " ", datetime),
    datetime = lubridate::ymd_hm(datetime)
  ) |>
  janitor::clean_names()

solar_data
```

## The basic app

```r
library(shiny)

ui <- fluidPage(
  headerPanel("Solar dashboard"),
  sidebarPanel(
    sliderInput("date_range", "Subset dates", min = as.Date('2024-07-15'), max = as.Date('2025-10-05'),
                value = c(as.Date('2024-07-15'), as.Date('2025-10-05'))),
  ),
  mainPanel(
    plotOutput("solar_plot")
  )
)

server <- function(input, output) {
  solar_data <- read.csv(here::here("data", "smartmeter.csv")) |>
    pivot_longer(
    cols = starts_with("X"),
    names_to = "datetime",
    values_to = "energy_kwh"
  ) |>
  mutate(
    datetime = gsub("X(\\d{2}\\.\\d{2})\\.\\.\\.(\\d{2}\\.\\d{2})", "\\1", datetime),
    energy_kwh = as.numeric(energy_kwh),
    datetime = paste0(DATE, " ", datetime),
    datetime = lubridate::ymd_hm(datetime)
  ) |>
  janitor::clean_names()

  output$solar_plot <- renderPlot({
    solar_data <- solar_data |>
      filter(datetime >= input$date_range[1] & datetime <= input$date_range[2])
    ggplot(solar_data, aes(x = datetime, y = energy_kwh)) +
      geom_line() +
      labs(y = 'kWh', x = 'Date') +
      theme_minimal()
  })
}
```

# Tabsets and layout patterns

## How to implement tabsets (step-by-step)

1. Decide what content belongs together — group related plots, tables or controls.
2. Use `tabsetPanel(id = 'tabs', tabPanel('A', ...), tabPanel('B', ...))` in your UI.
3. If you need to react to which tab is active, give the tabset an `id` and inspect `input$tabs` on the server.

## How to implement tabsets (example)

Small example:

```r
ui <- fluidPage(
  tabsetPanel(id = 'main_tabs',
    tabPanel('Overview', plotOutput('p1')),
    tabPanel('Details', plotOutput('p2'))
  ),
  mainPanel(
    textOutput('which_tab')
  )
)

server <- function(input, output) {
  output$which_tab <- renderText({ paste("Current tab:", input$main_tabs)})
}
```

## Updating our app to include a tabset

```r
library(shiny)
library(DT)

ui <- fluidPage(
  headerPanel("Solar dashboard"),
  sidebarPanel(
    sliderInput("date_range", "Subset dates", min = as.Date('2024-07-15'), max = as.Date('2025-10-05'),
                value = c(as.Date('2024-07-15'), as.Date('2025-10-05'))),
  ),
  mainPanel(
    tabsetPanel(
      tabPanel("Plot", plotOutput("solar_plot")),
      tabPanel("Data", DTOutput("data_table"))
    )
  )
)

server <- function(input, output) {
  solar_data <- read.csv(here::here("data", "smartmeter.csv")) |>
    pivot_longer(
    cols = starts_with("X"),
    names_to = "datetime",
    values_to = "energy_kwh"
  ) |>
  mutate(
    datetime = gsub("X(\\d{2}\\.\\d{2})\\.\\.\\.(\\d{2}\\.\\d{2})", "\\1", datetime),
    energy_kwh = as.numeric(energy_kwh),
    datetime = paste0(DATE, " ", datetime),
    datetime = lubridate::ymd_hm(datetime)
  ) |>
  janitor::clean_names()

  output$solar_plot <- renderPlot({
    solar_data <- solar_data |>
      filter(datetime >= input$date_range[1] & datetime <= input$date_range[2])
    ggplot(solar_data, aes(x = datetime, y = energy_kwh)) +
      geom_line() +
      labs(y = 'kWh', x = 'Date') +
      theme_minimal()
  })

  output$data_table <- renderDT({
    solar_data <- solar_data |>
      filter(datetime >= input$date_range[1] & datetime <= input$date_range[2])
    solar_data
  })
}
```

## When to use tabsets

- Use for logically separate views or different analysis perspectives of the same data (like our three framings).
- Avoid deep nesting of tabs (it adds cognitive load). Prefer progressive disclosure: keep primary controls visible and move advanced filters to secondary tabs.

# Reactive variables & shared datasets

## Reactive variables & shared datasets

You may have noticed in our app we are re-cleaning and processing the dataset inside each `render*()` function. This is inefficient and error-prone.

::: {.fragment}
Instead, we can create shared reactive expressions that parse and clean the data once, and then multiple outputs can re-use the cleaned data.
:::

## Reactive variables & shared datasets

To implement:

::: {.columns}
::: {.column width='50%'}


```r
# Shared reactive dataset
solar_data <- reactive({
  df <- read.csv(here::here("data", "smartmeter.csv")) |>
    pivot_longer(
      cols = starts_with("X"),
      names_to = "datetime",
      values_to = "energy_kwh"
    ) |>
    mutate(
      datetime = gsub("X(\\d{2}\\.\\d{2})\\.\\.\\.(\\d{2}\\.\\d{2})", "\\1", datetime),
      energy_kwh = as.numeric(energy_kwh),
      datetime = paste0(DATE, " ", datetime),
      datetime = lubridate::ymd_hm(datetime)
    ) |>
    janitor::clean_names()
  df
})
```
:::
::: {.column width='50%'}

::: {.fragment}

Then inside `renderPlot()` or `renderDT()` we call `solar_data()` to get the cleaned data frame.

```r
output$solar_plot <- renderPlot({
  df <- solar_data() |>
    filter(datetime >= input$date_range[1] & datetime <= input$date_range[2])
  ggplot(df, aes(x = datetime, y = energy_kwh)) +
    geom_line() +
    labs(y = 'kWh', x = 'Date') +
    theme_minimal()
})
```

:::
:::
:::

## Best practice checklist

::: {.incremental}

- Validate early: use `req()` and `validate()` at the top of reactive expressions
- Keep single responsibility: each reactive does one transformation step and you chain them (parse -> clean -> aggregate)
- Use descriptive names and document the contract for each reactive (inputs, outputs, error modes)

:::

# Other inputs and outputs

## File inputs

So far we have hard-coded the data source. To make the app reusable, we can add a file input control to let users upload their own solar CSV.

```r
fileInput("solar_file", "Upload solar data (CSV)", accept = c('.csv'))
```

Then inside the `solar_data` reactive we check if a file is uploaded and read it.

```r
solar_data <- reactive({
  req(input$solar_file) # require a file
  read.csv(input$solar_file$datapath)
  # ... rest of parsing and validation ...
})
```

## Showing and hiding UI elements

You might only want to show certain controls or outputs based on user selections.

For example, if you are changing `geoms` then the user might want to include a parameter that only applies to one geom.

## Enter the `conditionalPanel`

```r
conditionalPanel(
  condition = "input.geom_type == 'hist'",
  sliderInput("bin_width", "Bin Width", min = 1, max = 30, value = 7)
)
```

Here, the `condition` is in JavaScript. In `R` land, you read this as

```r
inpuut$geom_type == 'hist'
```

## Example of conditional UI

```r
# client
radioButtons("plot_geom", "Plot type",
                 choices = c("Line" = "line", "Histogram" = "hist"),
                 selected = "line"),
conditionalPanel(
  condition = "input.plot_geom == 'hist'",
  sliderInput("bins", "Number of bins", min = 5, max = 60, value = 30),
  selectInput("aggregation_size", "Aggregation type", choices = c("None", "Daily", "Weekly", "Monthly")),
)

# server

solar_data_aggregated <- reactive({
  req(solar_data_filtered())
  if (input$aggregation_size == "Daily") {
    solar_data_filtered() |>
      group_by(date) |>
      summarise(energy_kwh = sum(energy_kwh, na.rm = TRUE))
  } else if (input$aggregation_size == "Weekly") { ... }
})
```

## File downloading

You can let users download processed datasets or reports using `downloadButton()` in the UI and `downloadHandler()` on the server.

```r
downloadButton("download_plot", "Download Plot")

# server

output$download_plot <- downloadHandler(
  filename = function() { paste("solar_plot", Sys.Date(), ".png", sep = "") },
  content = function(file) {
    ggsave(file, plot = solar_plot(), device = "png", bg = "white", width = 8, height = 6)
  }
)
```

# On-the-fly data manipulation

## On-the-fly data manipulation

You can let users manipulate data on-the-fly using inputs that control filtering, aggregation, or transformations.

In our solar app, we could let users input their price per kWh and feed-in tariff to calculate potential savings.

## `observeEvent`

Sometimes you want to trigger something when something else happens, like when a button is clicked, rather than on every input change. If you have a long running computation, you might want to only run it when the user clicks "Update".

This is where we use `observeEvent()`:

```r
# client

actionButton("update", "Update calculations")

# server

observeEvent(input$update, {
  # Re-run expensive calculations here
  solar_data_priced <- solar_data_filtered()
  solar_data_priced$cost <- input$electricity_price * solar_data_priced$energy_kwh
  solar_data_priced$total_cost <- cumsum(solar_data_priced$cost)
})
```

## Dynamic UI generation

You can also use `actionButton` with `reactiveValues` to let users input multiple conditions without pre-specifying the numbers.

```r
# client

div(id = "price_inputs",
  numericInput("electricity_price_1", "Price per kwh", value = 0.28, min = 0)
),
div(style = "text-align: right;",
  actionButton("add_price", "Add another price"),
)

# server


n_prices <- reactiveVal(1)
observeEvent(input$add_price, {
  n <- n_prices() + 1
  n_prices(n)

  insertUI(
    selector = "#price_inputs",
    where = "beforeEnd",
    ui = numericInput(
      paste0("electricity_price_", n), 
      paste("Price per kwh"), value = 0.28, min = 0)
  )
})


solar_data_priced <- reactive({
  req(prices())
  solar_data_priced <- solar_data_filtered()
  for (i in 1:n_prices()) {
    solar_data_priced[, paste0("electricity_price_", i)] <- prices()[i] * solar_data_priced$energy_kwh
    solar_data_priced[, paste0("total_cost_", i)] <- cumsum(solar_data_priced[, paste0("electricity_price_", i)])
  }

  solar_data_priced
})
```

## Code management

By this point, your `app.R` file may be getting quite long. To keep things manageable:

- Split UI and server into separate files (`ui.R` and `server.R`)
- Modularise repeated components into functions or modules and then source them

::: {.fragment}
When using `source`, remember the path is relative to the app's working directory, not the file location.
:::

::: {.fragment}
You can't define _variables_ in sourced files and expect them to be available in the main app. Instead, define _functions_ that return values, and then use the functions inside `reactive` or similar.
:::

::: {.fragment}
Thinking in this modularised, functional way is similar to the workflow in `targets`, and helps to avoid the 1000-line script problem. Get in the habit early!
:::




## Recap: Packaging shiny apps in an R package

Recall the R package structure:

```
my_package/
  R/
    functions.R
    plots.R
  man/
    my_function.Rd
  vignettes/
    my_vignette.Rmd
```

## Recap: Packaging shiny apps in an R package

To include a shiny app, create an `inst/app/` directory inside your package:

::: {.columns}
::: {.column width='50%'}
```
my_package/
  R/
    functions.R
    plots.R
    man/
    my_function.Rd
  vignettes/
    my_vignette.Rmd
  inst/
    app/
      app.R
      www/
        styles.css
        script.js
      data/
        dataset.csv
```
:::
::: {.column width='50%'}
::: {.fragment}
Access things inside the package using `system.file()`:

```r
dataset <- read.csv(system.file("app/data/dataset.csv", package = "my_package"))
```

::: {.fragment}
Or export them using `roxygen` and then use as normal
:::
:::
:::
:::

# Demo

## Recap

- Tabsets for organizing views
- Shared reactive datasets for efficiency
- Conditional UI elements
- On-the-fly data manipulation with `observeEvent`
- Packaging shiny apps in an R package




